{"componentChunkName":"component---src-templates-blog-post-js","path":"/translation/500ms-to-1.7ms-in-react:-a-journey-and-a-checklist/","result":{"data":{"site":{"siteMetadata":{"title":"Ykss","author":"[Ykss]","siteUrl":"https://ykss.netlify.app","comment":{"disqusShortName":"","utterances":"ykss/ykss.netlify.com"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"6e3c8225-4ae2-53d0-b400-f6e0dbe9d170","excerpt":"원문: 500ms to 1.7ms In React: A Journey And A Checklist  이 글은 중국어로도 번역되어 있습니다. (by Qlly) Link1 Link2 모든 앱에서, 그리고 모든 개발자의 특정 개발 단계에서 성능 개선이 필요한 시기는 반드시 발생합니다. 리액트에서 성능을 개선하는 방법에 대한 매주 좋은 글과 자원이 있으며, 이 글도 예외는 아닙니다. 저는 제가 겪은 성능 병목 현상을 500ms에서 1.7ms…","html":"<blockquote>\n<p>원문: <a href=\"https://orizens.com/blog/500ms-to-1-7ms-in-react-a-journey-and-a%20checklist/\">500ms to 1.7ms In React: A Journey And A Checklist</a></p>\n</blockquote>\n<p><img src=\"https://orizens.com/static/fcc4b34baa61409dd4021613fa6471ab/0e329/duck.jpg\"></p>\n<blockquote>\n<p>이 글은 중국어로도 번역되어 있습니다. (by <a href=\"https://blog.csdn.net/qq_29750277/category_7801221.html\">Qlly</a>) <a href=\"https://juejin.cn/post/7133137152199622669\">Link1</a> <a href=\"https://blog.csdn.net/qq_29750277/article/details/126409675?spm=1001.2014.3001.5501\">Link2</a></p>\n</blockquote>\n<p>모든 앱에서, 그리고 모든 개발자의 특정 개발 단계에서 성능 개선이 필요한 시기는 반드시 발생합니다. 리액트에서 성능을 개선하는 방법에 대한 매주 좋은 글과 자원이 있으며, 이 글도 예외는 아닙니다. 저는 제가 겪은 성능 병목 현상을 500ms에서 1.7ms까지 줄였었던 여정과 결론을 공유하고자 합니다.</p>\n<p>성능 개선 전:</p>\n<p><img src=\"https://orizens.com/static/024e3ab9517f66384fbf86c99b779184/f6f7a/BEFORE.png\"></p>\n<p>성능 개선 후:</p>\n<p><img src=\"https://orizens.com/static/08c9dbd26b04604510e76bac3750b404/3ddad/AFTER.png\"></p>\n<h2 id=\"언제-성능이-감소할까요\" style=\"position:relative;\"><a href=\"#%EC%96%B8%EC%A0%9C-%EC%84%B1%EB%8A%A5%EC%9D%B4-%EA%B0%90%EC%86%8C%ED%95%A0%EA%B9%8C%EC%9A%94\" aria-label=\"언제 성능이 감소할까요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>언제 성능이 감소할까요?</h2>\n<p>저는 성능 감소를 알아차렸을 때 성능 개선을 시작하는 것에 대해 동의합니다. 즉, 저는 평소에 <code class=\"language-text\">useMemo()</code>와 <code class=\"language-text\">React.memo()</code>를 매 상태마다 사용하지 않습니다. 메모이제이션이 필요하지 않은 몇 가지 사용 사례가 존재하기 때문입니다. 즉, 저는 “과도한 메모이제이션”을 지양하고 너무 이른 시기에 최적화하지 않는 것을 권장합니다.</p>\n<p>제가 작업하고 있는 사례의 경우 UI가 매우 느릿느릿하게 느껴졌습니다. ─ 특히 0.5초의 대기시간이 눈에 띕니다. <a href=\"https://web.dev/first-meaningful-paint/\">첫 번째 의미 있는 페인트</a>(First Meaningful Paint)라는 용어는 첫 번째가 아닐 때도 적용됩니다.🙂 주의력 지속 시간은 일반적으로 낮기 때문에 느린 UI는 사용자를 이탈시킬 수 있습니다.</p>\n<h2 id=\"설정-및-환경\" style=\"position:relative;\"><a href=\"#%EC%84%A4%EC%A0%95-%EB%B0%8F-%ED%99%98%EA%B2%BD\" aria-label=\"설정 및 환경 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>설정 및 환경</h2>\n<p>이 성능 개선 여정에는 다음이 포함됩니다:</p>\n<ol>\n<li><code class=\"language-text\">React 17</code></li>\n<li>기본 UI 라이브러리 <code class=\"language-text\">차크라(Chakra)-UI</code></li>\n<li>상태 관리 도구 <code class=\"language-text\">리덕스 툴킷(Redux Toolkit)</code></li>\n<li>성능 문제 원인 <code class=\"language-text\">react-table v7</code></li>\n</ol>\n<h2 id=\"성능-문제\" style=\"position:relative;\"><a href=\"#%EC%84%B1%EB%8A%A5-%EB%AC%B8%EC%A0%9C\" aria-label=\"성능 문제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>성능 문제</h2>\n<p>제 사용 사례의 테이블은 셀에 대한 커스텀 렌더러가 거의 없는 커스텀 그리드입니다. 테이블의 인스턴스는 다른 컴포넌트와 함께 부모 컴포넌트의 일부입니다. 첫 번째 렌더링은 때때로 잘 진행되었지만, 부모 컴포넌트 안의 훅 또는 부모 컴포넌트와 관련된 상태가 업데이트가 있을 때 테이블이 리렌더링하는 데 <strong>0.5초나 걸리는</strong> 느린 UI가 변경이 발생합니다. UX를 사용하면, UI가 잠시 정지된 뒤 약간의 움직임을 볼 수 있습니다. 테이블은 심지어 데이터(행과 열)가 전혀 변경되지 않은 경우에도 다시 렌더링 됩니다.</p>\n<h2 id=\"단계-1---큰-컴포넌트를-잘-정의된-작은-컴포넌트로-분해\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EA%B3%84-1---%ED%81%B0-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A5%BC-%EC%9E%98-%EC%A0%95%EC%9D%98%EB%90%9C-%EC%9E%91%EC%9D%80-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A1%9C-%EB%B6%84%ED%95%B4\" aria-label=\"단계 1   큰 컴포넌트를 잘 정의된 작은 컴포넌트로 분해 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단계 1 - 큰 컴포넌트를 잘 정의된 작은 컴포넌트로 분해</h2>\n<p><code class=\"language-text\">react-table</code>의 훅은 UI를 노출하지 않으므로 문서에 따라서 UI를 구현해야 합니다. 대부분의 예제는 잘 작동하는 단순한 테이블의 중첩되지 않은 플랫 버전을 보여줍니다. 테이블 컴포넌트는 약 <strong>200줄 이상</strong>의 중첩되거나 중첩되지 않은 jsx 컴포넌트로 구성되어 있습니다. 중첩되지 않은 jsx 중 일부는 행과 행 헤더를 렌더링하는 <code class=\"language-text\">.map()</code> 순회를 포함하고 있습니다.</p>\n<p>이 시점에서, 그것을 더 작은 컴포넌트로 분해하는 리팩터링이 필요하다는 것이 명백했습니다. 래퍼 컴포넌트로 캡슐화될 수 있는 코드 블록을 쉽게 찾을 수 있었습니다. 예를 들어 <code class=\"language-text\">&lt;TableHeader/></code>,<code class=\"language-text\">&lt;TableRows/></code> 등이 있습니다. 이 단계는 테이블을 더 작고, 읽기 쉽게, 그리고 추론하기 쉽게 만듭니다. 몇 개의 블록을 컴포넌트에 캡슐화함으로써 얻을 수 있는 이점 중 하나는 프로퍼티가 원시 타입일때 불필요한 리렌더링을 줄일 수 있는 것입니다. 이 단계만으로도 <strong>0.5초</strong>의 멈춤을 <strong>150ms</strong>로 감소시킵니다. 이것은 훌륭하지만, 여전히 <strong>350ms</strong>는 느리게 느껴집니다.</p>\n<h2 id=\"단계-2---reactmemo-컬렉션-컴포넌트\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EA%B3%84-2---reactmemo-%EC%BB%AC%EB%A0%89%EC%85%98-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8\" aria-label=\"단계 2   reactmemo 컬렉션 컴포넌트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단계 2 - React.memo() 컬렉션 컴포넌트</h2>\n<p>배열, 객체, 함수와 같은 원시 타입이 아닌 프로퍼티를 포함하는 컴포넌트의 경우, 더 자세히 살펴봐야 했습니다. <code class=\"language-text\">React.memo</code>를 사용하면서 리렌더링을 줄일 수 있었지만, 렌더에서 정적 객체 프로퍼티를 제거하는 것도 도움이 되었습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> config <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">headerHandlers</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">isCustom</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">rowHandlers</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">isCustomPadding</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">paginationConfig</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">autoResetPage</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">autoResetGlobalFilter</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">initialState</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">pageSize</span><span class=\"token operator\">:</span> <span class=\"token number\">20</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token operator\">&lt;</span>ReadMTable <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span>config<span class=\"token punctuation\">}</span> data<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>events<span class=\"token punctuation\">}</span> columns<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>eventColumns<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span></code></pre></div>\n<p><code class=\"language-text\">.map()</code>을 사용하여 배열을 통해 반복하는 <strong>컬렉션</strong> 컴포넌트의 경우, 각 항목이 컴포넌트에 매핑되고 고유한 키를 얻도록 했습니다. 이는 컴포넌트가 원시 타입의 프로퍼티를 포함할 때, 렌더링하지 않고 다시 사용할 수 있음을 의미합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> ReadMTableRows <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">memo</span><span class=\"token punctuation\">(</span>EventsTableRows<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">EventsTableRows</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span>\n  rows<span class=\"token punctuation\">,</span>\n  prepareRow<span class=\"token punctuation\">,</span>\n  onClick<span class=\"token punctuation\">,</span>\n  isRowDisabled<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token operator\">:</span> TableRowsProps</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> rows<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">></span>\n      <span class=\"token punctuation\">{</span>rows<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">row</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>\n        <span class=\"token operator\">&lt;</span>TableRow\n          row<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token function\">prepareRow</span><span class=\"token punctuation\">(</span>row<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n          key<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">event-table-row-</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>row<span class=\"token punctuation\">.</span>id<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">}</span>\n          onRowClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>onClick<span class=\"token punctuation\">}</span>\n          disabled<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>isRowDisabled<span class=\"token punctuation\">}</span>\n        <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n      <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span><span class=\"token operator\">></span>\n  <span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위에 패턴에 따라서, 전체 <strong>0.5초</strong>가 <strong>300ms</strong>로 감소하였습니다. 꽤 기뻤지만, 개선의 여지가 더 보였습니다.</p>\n<h2 id=\"단계-3---jsx의-const-변수를-컴포넌트로-변환\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EA%B3%84-3---jsx%EC%9D%98-const-%EB%B3%80%EC%88%98%EB%A5%BC-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A1%9C-%EB%B3%80%ED%99%98\" aria-label=\"단계 3   jsx의 const 변수를 컴포넌트로 변환 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단계 3 - jsx의 const 변수를 컴포넌트로 변환</h2>\n<p>이 단계에서 테이블의 일부 프로퍼티를 사용하는 jsx 코드를 가리키는 몇 가지 상수가 있음을 확인했습니다. 다시 한 번, 리액트의 컴포넌트 렌더링 생명 주기에서 원시 타입 프로퍼티의 이점을 얻기 위해, 그것들을 아래와 같이 컴포넌트로 변환했습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// BEFORE</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">renderTableTitle</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">title<span class=\"token punctuation\">,</span> totalRows</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">&lt;</span>Flex alignItems<span class=\"token operator\">=</span><span class=\"token string\">\"center\"</span><span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>Heading <span class=\"token keyword\">as</span><span class=\"token operator\">=</span><span class=\"token string\">\"h4\"</span> fontWeight<span class=\"token operator\">=</span><span class=\"token string\">\"bold\"</span><span class=\"token operator\">></span>\n        <span class=\"token punctuation\">{</span>title<span class=\"token punctuation\">}</span>\n      <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>Heading<span class=\"token operator\">></span>\n      <span class=\"token punctuation\">{</span>totalRows<span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>Flex<span class=\"token operator\">></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 이것은 항상 호출됩니다.</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token function\">renderTableTitle</span><span class=\"token punctuation\">(</span><span class=\"token string\">'student statistics'</span><span class=\"token punctuation\">,</span> page<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// AFTER</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">TableTitle</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> title<span class=\"token punctuation\">,</span> totalRows <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">&lt;</span>Flex alignItems<span class=\"token operator\">=</span><span class=\"token string\">\"center\"</span><span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>Heading <span class=\"token keyword\">as</span><span class=\"token operator\">=</span><span class=\"token string\">\"h4\"</span> fontWeight<span class=\"token operator\">=</span><span class=\"token string\">\"bold\"</span><span class=\"token operator\">></span>\n        <span class=\"token punctuation\">{</span>title<span class=\"token punctuation\">}</span>\n      <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>Heading<span class=\"token operator\">></span>\n      <span class=\"token punctuation\">{</span>totalRows<span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>Flex<span class=\"token operator\">></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 제목(string) 또는 page.length(number)가 변경 될 때 다시 렌더링 됩니다.</span>\n<span class=\"token operator\">&lt;</span>TableTitle title<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>title<span class=\"token punctuation\">}</span> totalRows<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>page<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">title</code> 또는 <code class=\"language-text\">page.length</code>가 변경될 때, <code class=\"language-text\">&lt;TableTitle /></code> 컴포넌트가 다시 렌더링 되는 것을 쉽게 볼 수 있으며, 둘 다 원시 타입 프로퍼티입니다. 컴포넌트로 사용할 경우, 앱은 리액트 컴포넌트 재조정 생명주기의 이점을 누릴 수 있고, props가 같은 값을 가지고 있는 한 컴포넌트는 리렌더링 되지 않습니다. <strong>동일한 값</strong>으로, <strong>원시 타입</strong> 값(number, string, boolean) 또는 동일한 참조 <strong>원시 타입이 아닌</strong> 값(function, object)을 참조하고 있습니다.(이것은 여러 전략에 의해 달성됩니다: 스토어의 참조, 메모 된 값 또는 정적 참조)</p>\n<p>함수 호출은 항상 발생하고 jsx를 다시 빌드하기 때문에, jsx의 const 변수를 컴포넌트로 변환하는 것이 더 성능이 좋은 것으로 간주할 수 있습니다.</p>\n<p>테이블 렌더 주기의 범위에서 이러한 컴포넌트가 각 셀에 렌더링 될 때, 이 전략은 많은 리렌더링을 절약합니다.</p>\n<h2 id=\"단계-4---하얀-토끼-쫓기\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EA%B3%84-4---%ED%95%98%EC%96%80-%ED%86%A0%EB%81%BC-%EC%AB%93%EA%B8%B0\" aria-label=\"단계 4   하얀 토끼 쫓기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단계 4 - 하얀 토끼 쫓기</h2>\n<p>(번역자 주 : 영어로 chasing the white rabbit은 불가능, 환상, 꿈을 쫓는 것을 의미합니다. 여기서는 원인을 끝까지 알아낸다라는 의미에 가깝습니다.)</p>\n<p>이 제목은 낚시성의 제목이지만, 컴포넌트가 리렌더링 되는 이유를 이해하려고 할 때 느끼는 기분만큼 충분히 재미있었습니다. 다행히 리액트 개발 도구(devtool)에는 <code class=\"language-text\">프로파일러(Profiler)</code> 도구가 포함되어 있습니다. <code class=\"language-text\">Record why each component rendered while profiling.(프로파일링 하는 동안 각 컴포넌트가 왜 렌더링 되었는지 기록)</code> 항목이 체크되었는지 설정을 확인해야 합니다.(이 대화 상자를 표시하려면 톱니바퀴 아이콘을 클릭하세요.) 지금부터, 성능이 좋지 않다고 의심되는 시나리오를 프로파일링 하려면 아래 순서를 따르세요.</p>\n<p><img src=\"https://orizens.com/static/2fe9f01e8a66f16daafa34c275826ec6/0c69d/perf-controls.png\"></p>\n<ol>\n<li>파란색 “프로파일링 시작” 버튼을 클릭한다.</li>\n<li>브라우저에서 시나리오를 실행한다.</li>\n<li>완료되면 동일한 버튼을 클릭하여 “프로파일링 중지”를 선택한다.</li>\n</ol>\n<p>그러면 프로필에 선택할 수 있는 불꽃 그래프와 순위 차트가 표시됩니다. 보통 <strong>노란색</strong> 막대를 찾고 “왜 이것이 렌더링 되었는지?”라는 질문에 대한 힌트를 보기 시작합니다. 여기엔 리팩터링을 하거나 컴포넌트가 어떻게 구성되었는지를 다시 생각해 볼 수 있는 몇 가지 유용한 힌트가 있습니다.</p>\n<ol>\n<li>변경 사항이 있는 특정 props를 가리킵니다.</li>\n<li>변경 사항이 있는 훅을 가리킵니다. (슬프게도, 우리가 가진 것은 훅의 번호 뿐입니다.)</li>\n<li>렌더링 된 부모 컴포넌트를 나타냅니다.</li>\n<li>첫 번째 렌더링을 나타냅니다.</li>\n</ol>\n<p>이제 추적이 시작됩니다. 저의 테이블 사례는 제가 만든 <a href=\"https://orizens.com/blog/how-to-let-your-react-code-speak-for-itself/\">커스텀 훅</a>에서 반환된 데이터 중에 일부를 메모해야 한다는 것을 깨닫게 해주는 유용한 힌트가 거의 없었습니다.</p>\n<p><img src=\"https://orizens.com/static/3e774bd8e4d8837526bd63ecda644e54/ee3fb/props-changed.png\"></p>\n<p>막대에 커서를 올리면 DOM의 실제 컴포넌트가 표시됩니다. 여기서 특정 컴포넌트가 다시 렌더링 되어야 하는지 여부를 쉽게 분석할 수 있습니다. 이제 렌더링을 해야 할 때는 구현을 자세히 살펴보고, props나 훅 또는 이와 관련된 다른 데이터 소스를 통해 렌더링의 원인이 되는 데이터를 찾아야 합니다.</p>\n<p>props가 함수 콜백을 포함한 경우, <code class=\"language-text\">useCallback()</code>으로 감싸면 렌더링 주기를 줄이는 데 도움이 될 수 있습니다.</p>\n<p>답을 찾는 것에 대해서는 마법의 규칙이 존재하지 않습니다. 때때로 <code class=\"language-text\">React.memo()</code>는 효과가 있지만, 그러기 위해서는 시행착오가 필요합니다. 분명히 하자면, 저는 해결책으로 <code class=\"language-text\">React.memo()</code>를 홍보하는 것이 <strong>아닙니다</strong>. 일반적으로 동일한 데이터에서 재생성되는 원시 타입이 아닌 객체를 찾기 위해 컴포넌트 트리를 더 파헤치는 것을 선호합니다. 이 경우에는 스토어를 사용 할 수 없는 경우에는 <code class=\"language-text\">useMemo()</code>를 사용하는 것을 선호합니다.</p>\n<p><img src=\"https://orizens.com/static/252b3ce2060787077783f2a399c4f622/47730/hooks-changed.png\"></p>\n<p>막대의 툴팁에서 <b>“훅이 변경되었음”</b>이 표시되면, 컴포넌트로 이동하여 연결된 훅을 주의 깊게 검토해야 합니다.</p>\n<p><img src=\"https://orizens.com/static/0ac6ef86582b7ee0f804afcaef1daf2c/dea13/component-hooks.png\"></p>\n<p>이 여정을 마무리하자면, 몇 가지 성능 병목 현상은 쉽게 발견하고 해결할 수 있습니다. 일부는 시행착오뿐만 아니라 리액트 컴포넌트 트리에서 심층적인 여정이 필요할 수 있습니다.</p>\n<p>성능 프로파일링은 애플리케이션의 속도가 현저히 느려질 때 이루어져야 합니다. 가장 중요한 것은 근본 원인을 찾을 때까지 조사가 수행되어야 하는 것입니다. 때때로 jsx 빌드 방식을 변경해야 할 수도 있습니다. 만약 그렇다면 유지 관리해야 할 추가적인 코드를 추가하기 전에 신중하게 생각하는 것이 좋습니다.</p>\n<h3 id=\"리액트-성능에-대해서-더-자세히-알고-싶으신가요\" style=\"position:relative;\"><a href=\"#%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%84%B1%EB%8A%A5%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EB%8D%94-%EC%9E%90%EC%84%B8%ED%9E%88-%EC%95%8C%EA%B3%A0-%EC%8B%B6%EC%9C%BC%EC%8B%A0%EA%B0%80%EC%9A%94\" aria-label=\"리액트 성능에 대해서 더 자세히 알고 싶으신가요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>리액트 성능에 대해서 더 자세히 알고 싶으신가요?</h3>\n<p>리액트 성능을 향상하는 방법에 대한 질문이나 아이디어가 있다면, <a href=\"https://orizens.com/contact\">저에게 연락</a> 하거나 <a href=\"https://twitter.com/orizens\">트윗</a> 해주세요.</p>\n<p>이 글은 <a href=\"https://readm.app\">ReadM</a> 애플리케이션의 사례를 기반으로 작성되었습니다. - <a href=\"https://readm.app\">ReadM</a> 앱은 초보자나 아이들의 영어 학습을 빠르게 돕는 서비스입니다.</p>\n<blockquote>\n<p>🚀 한국어로 된 프런트엔드 아티클을 빠르게 받아보고 싶다면 Korean FE Article(<a href=\"https://kofearticle.substack.com/\">https://kofearticle.substack.com/</a>)을 구독해주세요!</p>\n</blockquote>","frontmatter":{"title":"(번역) 리액트 성능 최적화, 500ms 에서 1.7ms 까지 : 그 여정과 체크리스트","date":"August 31, 2022","thumbnail":null}}},"pageContext":{"slug":"/translation/500ms-to-1.7ms-in-react:-a-journey-and-a-checklist/","previous":{"fields":{"slug":"/web/pwa/"},"frontmatter":{"title":"[PWA] 프로그레시브 웹앱(Progressive Web App)","category":"Web","draft":false}},"next":{"fields":{"slug":"/typescript/type_vs_interface/"},"frontmatter":{"title":"[Typescript] 타입(Type)과 인터페이스(Interface)의 차이점","category":"Typescript","draft":false}}}},"staticQueryHashes":["3128451518","521680639"]}