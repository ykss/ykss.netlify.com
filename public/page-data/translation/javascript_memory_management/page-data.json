{"componentChunkName":"component---src-templates-blog-post-js","path":"/translation/javascript_memory_management/","result":{"data":{"site":{"siteMetadata":{"title":"Ykss","author":"[Ykss]","siteUrl":"https://ykss.netlify.app","comment":{"disqusShortName":"","utterances":"ykss/ykss.netlify.com"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"db91a106-dbd5-55d4-ba89-61c73c59579f","excerpt":"원문: JavaScript Memory Management: How to Avoid Common Memory Leaks and Improve Performance 애플리케이션을 최적화하는 데 도움이 되는 JS의 메모리 관리에 대해 설명합니다. javascript memory leak 목차 도입 자바스크립트 메모리 관리의 이해 1. 가비지 컬렉터 2. 스택 vs 힙 메모리 누수의 일반적인 원인 1. 순환 참조 2. 이벤트 리스너 3. 전역 변수 수동 메모리 관리 모범 사례 1. 약한 참조 사용…","html":"<blockquote>\n<p>원문: <a href=\"https://itnext.io/javascript-memory-management-how-to-avoid-common-memory-leaks-and-improve-performance-c018dbbca954\">JavaScript Memory Management: How to Avoid Common Memory Leaks and Improve Performance</a></p>\n</blockquote>\n<blockquote>\n<p>애플리케이션을 최적화하는 데 도움이 되는 JS의 메모리 관리에 대해 설명합니다.</p>\n</blockquote>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bCpGATft8RX8_SfH8WMcoQ.png\" alt=\"javascript memory leak\"></p>\n<h2 id=\"목차\" style=\"position:relative;\"><a href=\"#%EB%AA%A9%EC%B0%A8\" aria-label=\"목차 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>목차</h2>\n<ul>\n<li><a href=\"#%EB%8F%84%EC%9E%85\">도입</a></li>\n<li>\n<p><a href=\"#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC%EC%9D%98-%EC%9D%B4%ED%95%B4\">자바스크립트 메모리 관리의 이해</a></p>\n<ul>\n<li><a href=\"#1-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%ED%84%B0\">1. 가비지 컬렉터</a></li>\n<li><a href=\"#2-%EC%8A%A4%ED%83%9D-vs-%ED%9E%99\">2. 스택 vs 힙</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98%EC%9D%98-%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8-%EC%9B%90%EC%9D%B8\">메모리 누수의 일반적인 원인</a></p>\n<ul>\n<li><a href=\"#1-%EC%88%9C%ED%99%98-%EC%B0%B8%EC%A1%B0\">1. 순환 참조</a></li>\n<li><a href=\"#2-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A6%AC%EC%8A%A4%EB%84%88\">2. 이벤트 리스너</a></li>\n<li><a href=\"#3-%EC%A0%84%EC%97%AD-%EB%B3%80%EC%88%98\">3. 전역 변수</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%88%98%EB%8F%99-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EB%AA%A8%EB%B2%94-%EC%82%AC%EB%A1%80\">수동 메모리 관리 모범 사례</a></p>\n<ul>\n<li><a href=\"#1-%EC%95%BD%ED%95%9C-%EC%B0%B8%EC%A1%B0-%EC%82%AC%EC%9A%A9\">1. 약한 참조 사용</a></li>\n<li><a href=\"#2-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%ED%84%B0-API-%EC%82%AC%EC%9A%A9\">2. 가비지 컬렉터 API 사용</a></li>\n<li><a href=\"#3-%ED%9E%99-%EC%8A%A4%EB%83%85%EC%83%B7%EA%B3%BC-%ED%94%84%EB%A1%9C%ED%8C%8C%EC%9D%BC%EB%9F%AC-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\">3. 힙 스냅샷과 프로파일러 사용하기</a></li>\n</ul>\n</li>\n<li><a href=\"#%EA%B2%B0%EB%A1%A0\">결론</a></li>\n</ul>\n<h2 id=\"도입\" style=\"position:relative;\"><a href=\"#%EB%8F%84%EC%9E%85\" aria-label=\"도입 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>도입</h2>\n<p>웹 개발자는 작성하는 모든 코드가 애플리케이션의 성능에 영향을 미칠 수 있다는 것을 알고 있습니다. 자바스크립트에서 집중해야 할 가장 중요한 영역 중 하나는 메모리 관리입니다.</p>\n<p>사용자가 웹사이트와 상호작용할 때마다 새로운 객체, 변수, 함수가 생성된다고 생각해보세요. 주의하지 않으면 이러한 객체가 쌓여 브라우저의 메모리를 막고 전체 사용자 경험을 느리게 만들 수 있습니다. 이는 마치 정보 고속도로의 교통 체증과 같아서 사용자를 이탈하게 만드는 답답한 병목 현상입니다.</p>\n<p>이러한 현상을 꼭 겪을 필요는 없습니다. 올바른 지식과 기술을 활용하면 자바스크립트 메모리를 제어하고, 애플리케이션이 원활하고 효율적으로 실행되도록 할 수 있습니다. 이 글에서는 메모리 누수의 일반적인 원인과 이를 방지하기 위한 전략을 포함해 자바스크립트 메모리 관리의 전반적인 내용을 살펴봅니다. 전문가든 초보 개발자든 깔끔하고 간결하며 빠른 코드를 작성하는 방법을 더 깊이 이해하게 될 것입니다.</p>\n<h2 id=\"자바스크립트-메모리-관리의-이해\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC%EC%9D%98-%EC%9D%B4%ED%95%B4\" aria-label=\"자바스크립트 메모리 관리의 이해 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>자바스크립트 메모리 관리의 이해</h2>\n<h3 id=\"1-가비지-컬렉터\" style=\"position:relative;\"><a href=\"#1-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%ED%84%B0\" aria-label=\"1 가비지 컬렉터 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 가비지 컬렉터</h3>\n<p>자바스크립트 엔진은 <strong>가비지 컬렉터</strong>를 사용하여 더 이상 사용하지 않는 메모리를 확보합니다. 가비지 컬렉터의 역할은 애플리케이션에서 더 이상 사용하지 않는 객체를 식별하고 제거하는 것입니다. 가비지 컬렉터는 코드의 <em>객체</em>와 <em>변수</em>를 지속적으로 <em>모니터링하고</em> 어떤 객체가 여전히 <em>참조되고</em> 있는지 추적하여 이를 수행합니다. 가비지 컬렉터는 사용되지 않는 객체를 삭제할 대상으로 표시하고 객체가 사용 중이던 메모리를 확보합니다.</p>\n<p>가비지 컬렉터는 ”<strong>표시(mark) 및 정리(sweep)</strong>“라는 기술을 사용하여 메모리를 관리합니다. 아직 사용 중인 모든 객체를 표시한 다음, 힙을 ’<strong>정리</strong>‘하여 사용중으로 표시되지 않은 객체를 모두 제거합니다. 이 프로세스는 주기적으로 수행되며 힙의 메모리가 부족할 때도 수행되어 애플리케이션의 메모리 사용량이 항상 최대한 효율적으로 유지되도록 합니다.</p>\n<h3 id=\"2-스택-vs-힙\" style=\"position:relative;\"><a href=\"#2-%EC%8A%A4%ED%83%9D-vs-%ED%9E%99\" aria-label=\"2 스택 vs 힙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 스택 vs 힙</h3>\n<p>자바스크립트에서 메모리는 <strong>스택</strong>과 <strong>힙</strong>이라는 두 가지 주요 요소가 있습니다.</p>\n<p><strong>스택</strong>은 <em>함수</em>를 실행하는 동안에만 필요한 데이터를 저장하는 데 사용됩니다. 빠르고 <em>효율적</em>이지만 <em>용량이 제한</em>되어 있습니다. 함수가 호출되면 <em>자바스크립트 엔진은 함수의 변수와 매개변수를 스택으로 밀어넣고, 함수가 반환되면 다시 스택에서 꺼냅니다.</em> 스택은 빠른 액세스와 빠른 메모리 관리를 위해 사용됩니다.</p>\n<p>반면 <strong>힙</strong>은 <em>애플리케이션의 전체 수명</em> 동안 필요한 데이터를 저장하는 데 사용됩니다. 스택보다 <em>조금 느리고 덜 체계적</em>이지만 용량이 훨씬 큽니다. 힙은 여러 번 액세스해야 하는 <em>객체</em>, <em>배열</em> 및 기타 <em>복잡한 데이터 구조</em>를 저장하는 데 사용됩니다.</p>\n<h2 id=\"메모리-누수의-일반적인-원인\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98%EC%9D%98-%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8-%EC%9B%90%EC%9D%B8\" aria-label=\"메모리 누수의 일반적인 원인 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메모리 누수의 일반적인 원인</h2>\n<p>메모리 누수는 애플리케이션에 잠입해 성능 문제를 일으키는 교활한 적이 될 수 있다는 것을 잘 알고 계실 것입니다. 메모리 누수의 일반적인 원인을 이해하면 메모리 누수를 방지하는 데 도움이 될 수 있습니다.</p>\n<h3 id=\"1-순환-참조\" style=\"position:relative;\"><a href=\"#1-%EC%88%9C%ED%99%98-%EC%B0%B8%EC%A1%B0\" aria-label=\"1 순환 참조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 순환 참조</h3>\n<p>메모리 누수의 가장 일반적인 원인 중 하나는 <strong>순환 참조</strong>입니다. 순환 참조는 두 개 이상의 <em>객체가 서로를 참조</em>하여 가비지 컬렉터가 끊을 수 없는 순환을 생성할 때 발생합니다. 이로 인해 객체가 더 이상 필요하지 않게 되어도 오랫동안 메모리에 유지될 수 있습니다. 다음은 예시입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> object1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> object2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 객체1과 객체2 사이에 순환 참조를 생성합니다.</span>\nobject1<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> object2<span class=\"token punctuation\">;</span>\nobject2<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> object1<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// object1과 object2로 무언가를 수행합니다.</span>\n<span class=\"token comment\">// ...</span>\n\n<span class=\"token comment\">// 순환 참조를 끊으려면 object1과 object2를 null로 설정합니다.</span>\nobject1 <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\nobject2 <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이 예제에서는 <code class=\"language-text\">object1</code>과 <code class=\"language-text\">object2</code>라는 두 개의 객체를 생성하고 <code class=\"language-text\">next</code> 및 <code class=\"language-text\">prev</code> 프로퍼티를 추가하여 두 객체 사이에 순환 참조를 생성합니다. 그런 다음 <code class=\"language-text\">object1</code>과 <code class=\"language-text\">object2</code>를 <code class=\"language-text\">null</code>로 설정하여 순환 참조를 끊지만, 가비지 컬렉터가 순환 참조를 끊을 수 없기 때문에 객체가 더 이상 필요하지 않은 후에도 오랫동안 메모리에 유지되어 메모리 누수가 발생합니다.</p>\n<p>이러한 유형의 메모리 누수를 방지하려면 자바스크립트의 <code class=\"language-text\">delete</code> 키워드를 사용하여 순환 참조를 생성하는 프로퍼티를 제거하는 <code class=\"language-text\">\"수동 메모리 관리\"</code>라는 기술을 사용할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">delete</span> object1<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">delete</span> object2<span class=\"token punctuation\">.</span>prev<span class=\"token punctuation\">;</span></code></pre></div>\n<p>이러한 유형의 메모리 누수를 방지하는 또 다른 방법은 객체와 변수에 대한 약한 참조를 생성할 수 있는 <code class=\"language-text\">WeakMap</code>과 <code class=\"language-text\">WeakSet</code>을 사용하는 것입니다. <a href=\"#1-%EC%95%BD%ED%95%9C-%EC%B0%B8%EC%A1%B0-%EC%82%AC%EC%9A%A9\">이 옵션에 대한 자세한 내용은 이 글의 뒷부분에서 확인할 수 있습니다.</a></p>\n<h3 id=\"2-이벤트-리스너\" style=\"position:relative;\"><a href=\"#2-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A6%AC%EC%8A%A4%EB%84%88\" aria-label=\"2 이벤트 리스너 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 이벤트 리스너</h3>\n<p>메모리 누수의 또 다른 일반적인 원인은 <strong>이벤트 리스너</strong>입니다. 이벤트 리스너를 <em>요소에 연결</em>하면 리스너 함수에 대한 <em>참조가 생성</em>되어 가비지 컬렉터가 요소에서 사용하는 메모리를 확보하지 못하게 할 수 있습니다. 요소가 더 이상 필요하지 않을 때 리스너 함수를 제거하지 않으면 메모리 누수가 발생할 수 있습니다. 아래 예시를 참조하세요.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> button <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'my-button'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 버튼 요소에 이벤트 리스너를 붙입니다.</span>\nbutton<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Button was clicked!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 버튼이 무언가 동작을 합니다.</span>\n<span class=\"token comment\">// ...</span>\n\n<span class=\"token comment\">// DOM에서 버튼을 제거합니다.</span>\nbutton<span class=\"token punctuation\">.</span>parentNode<span class=\"token punctuation\">.</span><span class=\"token function\">removeChild</span><span class=\"token punctuation\">(</span>button<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이 예제에서는 버튼 요소에 이벤트 리스너를 연결한 다음 DOM에서 버튼을 제거합니다. 버튼 요소가 더 이상 문서에 없지만 이벤트 리스너는 여전히 연결되어 있으므로 리스너 함수에 대한 참조가 생성되어 <strong>가비지 컬렉터</strong>가 요소에서 사용하는 메모리를 확보하지 못합니다. 요소가 더 이상 필요하지 않을 때 리스너 함수를 제거하지 않으면 메모리 누수가 발생할 수 있습니다.</p>\n<p>이러한 유형의 메모리 누수를 방지하려면 요소가 더 이상 필요하지 않을 때 이벤트 리스너를 제거하는 것이 중요합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">button<span class=\"token punctuation\">.</span><span class=\"token function\">removeEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Button was clicked!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>또 다른 방법은 특정 이벤트 대상에 추가된 모든 이벤트 리스너를 제거하는 <code class=\"language-text\">EventTarget.removeAllListeners()</code> 메서드를 사용하는 것입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">button<span class=\"token punctuation\">.</span><span class=\"token function\">removeAllListeners</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"3-전역-변수\" style=\"position:relative;\"><a href=\"#3-%EC%A0%84%EC%97%AD-%EB%B3%80%EC%88%98\" aria-label=\"3 전역 변수 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 전역 변수</h3>\n<p>메모리 누수의 세 번째 일반적인 원인은 전역 변수입니다. <strong>전역 변수</strong>를 생성하면 코드의 어느 위치에서나 접근할 수 있으므로 더 이상 필요하지 않은 시점을 판단하기 어려울 수 있습니다. 이로 인해 변수가 필요하지 않게 되어도 오랫동안 메모리에 유지될 수 있습니다. 예를 들어 보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 전역 변수를 선언합니다.</span>\n<span class=\"token keyword\">let</span> myData <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">largeArray</span><span class=\"token operator\">:</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">fill</span><span class=\"token punctuation\">(</span><span class=\"token string\">'some data'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">id</span><span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// myData 변수로 무언가를 수행합니다.</span>\n<span class=\"token comment\">// ...</span>\n\n<span class=\"token comment\">// 참조를 끊기 위해 myData를 null로 설정합니다.</span>\nmyData <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이 예제에서는 전역 변수 <code class=\"language-text\">myData</code>를 생성하고 그 안에 대량의 데이터 배열을 저장합니다. 그런 다음 참조를 끊기 위해 <code class=\"language-text\">myData</code>를 <code class=\"language-text\">null</code>로 설정했지만 변수가 전역이므로 코드의 어느 위치에서나 여전히 접근할 수 있습니다. 더 이상 필요하지 않은 시점을 판단하기 어렵기 때문에, 변수가 더 이상 필요하지 않음에도 오랫동안 메모리에 유지되어 메모리 누수를 일으킬 수 있습니다.</p>\n<p>이러한 유형의 메모리 누수를 방지하려면 <code class=\"language-text\">\"함수 스코핑\"</code> 기법을 사용할 수 있습니다. 이 기법은 함수를 생성하고 해당 함수 내에서 변수를 선언하여 해당 <em>함수의 스코프</em> 내에서만 접근할 수 있도록 하는 것입니다. 이렇게 하면 함수가 더 이상 필요하지 않게 될 때, 변수가 자동으로 가비지 컬렉팅됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">myFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> myData <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">largeArray</span><span class=\"token operator\">:</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">fill</span><span class=\"token punctuation\">(</span><span class=\"token string\">'some data'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">id</span><span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// myData 변수로 무언가를 수행합니다.</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">myFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>또 다른 방법은 <code class=\"language-text\">var</code> 대신 자바스크립트의 <code class=\"language-text\">let</code>과 <code class=\"language-text\">const</code>를 사용하여 <em>블록 스코프 변수</em>를 생성하는 것입니다. <code class=\"language-text\">let</code>과 <code class=\"language-text\">const</code>로 선언된 변수는 해당 변수가 정의된 블록 내에서만 접근할 수 있으며 스코프를 벗어나면 자동으로 가비지 컬렉팅됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> myData <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">largeArray</span><span class=\"token operator\">:</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">fill</span><span class=\"token punctuation\">(</span><span class=\"token string\">'some data'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">id</span><span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// myData 변수로 무언가를 수행합니다.</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"수동-메모리-관리-모범-사례\" style=\"position:relative;\"><a href=\"#%EC%88%98%EB%8F%99-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EB%AA%A8%EB%B2%94-%EC%82%AC%EB%A1%80\" aria-label=\"수동 메모리 관리 모범 사례 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>수동 메모리 관리 모범 사례</h2>\n<p>자바스크립트는 애플리케이션의 메모리 사용량을 관리하는 데 도움이 되는 메모리 관리 도구와 기법을 제공합니다.</p>\n<h3 id=\"1-약한-참조-사용\" style=\"position:relative;\"><a href=\"#1-%EC%95%BD%ED%95%9C-%EC%B0%B8%EC%A1%B0-%EC%82%AC%EC%9A%A9\" aria-label=\"1 약한 참조 사용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 약한 참조 사용</h3>\n<p>자바스크립트에서 가장 강력한 메모리 관리 도구 중 하나는 <code class=\"language-text\">WeakMap</code>과 <code class=\"language-text\">WeakSet</code>입니다. 이들은 <em>객체와 변수에 대한 약한 참조</em>를 생성할 수 있는 특수 데이터 구조입니다. 약한 참조는 <strong>가비지 컬렉터</strong>가 객체가 사용하는 메모리를 확보하지 못하도록 막는다는 점에서 일반 참조와 다릅니다. 따라서 순환 참조로 인한 메모리 누수를 방지하는 데 유용한 도구입니다. 다음은 예시입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> object1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> object2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// WeakMap을 생성합니다.</span>\n<span class=\"token keyword\">let</span> weakMap <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">WeakMap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// object1을 WeakMap에 추가한 다음</span>\n<span class=\"token comment\">// object1에 WeakMap을 추가하여 순환 참조를 생성합니다.</span>\nweakMap<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>object1<span class=\"token punctuation\">,</span> <span class=\"token string\">'some data'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nobject1<span class=\"token punctuation\">.</span>weakMap <span class=\"token operator\">=</span> weakMap<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// weakSet을 생성하고 object2를 추가합니다.</span>\n<span class=\"token keyword\">let</span> weakSet <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">WeakSet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nweakSet<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>object2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 이 경우 가비지 컬렉터는 object1과 object2가 사용하는 메모리를 확보할 수 있습니다.</span>\n<span class=\"token comment\">// object1 과 object2의 참조가 약하기 때문입니다.</span></code></pre></div>\n<p>이 예제에서는 <code class=\"language-text\">object1</code>과 <code class=\"language-text\">object2</code>라는 두 개의 객체를 생성하고 각각 <code class=\"language-text\">WeakMap</code>과 <code class=\"language-text\">WeakSet</code>에 추가하여 이들 사이에 순환 참조를 생성합니다. 이러한 객체에 대한 참조가 약하기 때문에 가비지 컬렉터는 객체가 계속 참조되고 있음에도 불구하고 객체가 사용하는 메모리를 확보할 수 있습니다. 이렇게 하면 순환 참조로 인한 메모리 누수를 방지하는 데 도움이 될 수 있습니다.</p>\n<h3 id=\"2-가비지-컬렉터-api-사용\" style=\"position:relative;\"><a href=\"#2-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%ED%84%B0-api-%EC%82%AC%EC%9A%A9\" aria-label=\"2 가비지 컬렉터 api 사용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 가비지 컬렉터 API 사용</h3>\n<p>또 다른 메모리 관리 기법은 <strong>가비지 컬렉터 API</strong>를 사용하여 수동으로 가비지 컬렉션을 트리거하고 힙의 현재 상태에 대한 정보를 얻는 것입니다. 이는 메모리 누수 및 성능 문제를 디버깅하는 데 유용합니다. 다음은 예시입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> object1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> object2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// object1과 object2 사이에 순환 참조를 만듭니다.</span>\nobject1<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> object2<span class=\"token punctuation\">;</span>\nobject2<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> object1<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 수동으로 가비지 컬렉터를 호출합니다.</span>\n<span class=\"token function\">gc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이 예제에서는 <code class=\"language-text\">object1</code>과 <code class=\"language-text\">object2</code>라는 두 개의 객체를 생성하고 <code class=\"language-text\">next</code> 및 <code class=\"language-text\">prev</code> 프로퍼티를 추가하여 두 객체 사이에 순환 참조를 생성합니다. 그런 다음 <code class=\"language-text\">gc()</code> 함수를 사용하여 가비지 컬렉션을 수동으로 트리거하면 객체가 계속 참조되고 있음에도 불구하고 객체가 사용하는 메모리를 확보할 수 있습니다.</p>\n<p><code class=\"language-text\">gc()</code> 함수는 모든 자바스크립트 엔진에서 지원되는 것은 아니며, 엔진에 따라 동작이 다를 수 있다는 점에 유의해야 합니다. 또한 가비지 컬렉션을 수동으로 트리거하면 <em>성능에 영향을 미칠 수 있으므로</em> 필요한 경우에만 사용하는 것이 좋습니다.</p>\n<p>자바스크립트는 <code class=\"language-text\">gc()</code> 함수 외에도 자바스크립트 엔진의 <code class=\"language-text\">global.gc()</code> 함수와 일부 브라우저 엔진의 <code class=\"language-text\">performance.gc()</code> 함수를 제공합니다. 이 함수들은 힙의 현재 상태를 확인하고 가비지 컬렉션 프로세스의 성능을 측정하는 데 사용할 수 있습니다.</p>\n<h3 id=\"3-code-classlanguage-text힙-스냅샷과code-프로파일러-사용하기\" style=\"position:relative;\"><a href=\"#3-code-classlanguage-text%ED%9E%99-%EC%8A%A4%EB%83%85%EC%83%B7%EA%B3%BCcode-%ED%94%84%EB%A1%9C%ED%8C%8C%EC%9D%BC%EB%9F%AC-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"3 code classlanguage text힙 스냅샷과code 프로파일러 사용하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. <code class=\"language-text\">힙 스냅샷과</code> 프로파일러 사용하기</h3>\n<p>자바스크립트는 애플리케이션이 메모리를 사용하는 방식을 이해하는 데 도움이 되는 <strong>힙 스냅샷</strong>과 <strong>프로파일러</strong>도 제공합니다. <strong>힙 스냅샷</strong>을 사용하면 힙의 현재 상태를 스냅샷으로 찍고 이를 분석하여 어떤 객체가 가장 많은 메모리를 사용하는지 확인할 수 있습니다.</p>\n<p>다음은 힙 스냅샷을 사용하여 애플리케이션의 메모리 누수를 식별하는 방법에 대한 예시입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 힙 스냅샷을 시작합니다.</span>\n<span class=\"token keyword\">let</span> snapshot1 <span class=\"token operator\">=</span> performance<span class=\"token punctuation\">.</span><span class=\"token function\">heapSnapshot</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 메모리 누수를 유발하는 어떤 동작을 수행합니다.</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">100000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  myArray<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">largeData</span><span class=\"token operator\">:</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">fill</span><span class=\"token punctuation\">(</span><span class=\"token string\">'some data'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">id</span><span class=\"token operator\">:</span> i<span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 다른 힙 스냅샷을 실행합니다.</span>\n<span class=\"token keyword\">let</span> snapshot2 <span class=\"token operator\">=</span> performance<span class=\"token punctuation\">.</span><span class=\"token function\">heapSnapshot</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 두 스냅샷을 비교하여 어떤 객체가 생성되었는지 확인합니다.</span>\n<span class=\"token keyword\">let</span> diff <span class=\"token operator\">=</span> snapshot2<span class=\"token punctuation\">.</span><span class=\"token function\">compare</span><span class=\"token punctuation\">(</span>snapshot1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 차이를 분석하여 어떤 객체가 가장 많은 메모리를 사용하는지 확인 합니다.</span>\ndiff<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">item</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">.</span>size <span class=\"token operator\">></span> <span class=\"token number\">1000000</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이 예제에서는 대용량 데이터를 배열로 푸시하는 루프를 실행하기 전후에 두 개의 힙 스냅샷을 생성한 다음, 두 스냅샷을 비교하여 루프 중에 생성된 객체들을 확인합니다. 그런 다음 차이를 분석하여 어떤 객체가 가장 많은 메모리를 사용하는지 확인할 수 있으며, 이를 통해 대용량 데이터로 인한 메모리 누수를 식별하는 데 도움이 될 수 있습니다.</p>\n<p><strong>프로파일러</strong>를 사용하면 애플리케이션의 성능을 추적하고 메모리 사용량이 많은 영역을 식별할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> profiler <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Profiler</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nprofiler<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 메모리 누수를 유발하는 어떤 동작을 수행합니다.</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">100000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  myArray<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">largeData</span><span class=\"token operator\">:</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">fill</span><span class=\"token punctuation\">(</span><span class=\"token string\">'some data'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">id</span><span class=\"token operator\">:</span> i<span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nprofiler<span class=\"token punctuation\">.</span><span class=\"token function\">stop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> report <span class=\"token operator\">=</span> profiler<span class=\"token punctuation\">.</span><span class=\"token function\">report</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 보고서를 분석하여 메모리 사용량이 많은 영역을 식별합니다.</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> func <span class=\"token keyword\">of</span> report<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>func<span class=\"token punctuation\">.</span>memory <span class=\"token operator\">></span> <span class=\"token number\">1000000</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>func<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 예제에서는 자바스크립트 <strong>프로파일러</strong>를 사용하여 애플리케이션의 성능 추적을 시작 및 중지하고 있습니다. 보고서에는 호출된 함수와 각 함수에 대한 메모리 사용량에 대한 정보가 표시됩니다.</p>\n<p><strong>힙 스냅샷</strong>과 <strong>프로파일러</strong>는 모든 자바스크립트 엔진과 브라우저에서 지원되는 것은 아니므로 애플리케이션에서 사용하기 전에 호환성을 확인하는 것이 중요합니다.</p>\n<h2 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h2>\n<p>이제까지 가비지 컬렉션 프로세스, 다양한 메모리 유형, 자바스크립트에서 사용할 수 있는 메모리 관리 도구와 기법 등 자바스크립트 메모리 관리의 기본을 살펴보았습니다. 또한 메모리 누수의 일반적인 원인에 대해 설명하고 이를 방지하는 방법에 대한 예시를 제공했습니다.</p>\n<p>이러한 메모리 관리 모범 사례를 이해하고 구현하는 데 시간을 투자하면 메모리 누수 가능성을 줄이며 애플리케이션을 만들어낼 수 있습니다. 이 글이 도움이 되었다면 <strong>박수</strong>를 보내주셔서 응원해주시고, Medium에서 저를 <strong>팔로우</strong>하여 기술을 한 단계 더 발전시키는 데 도움이 되는 새로운 글과 학습 기회에 대한 최신 소식을 받아보세요.</p>\n<p><a href=\"https://easy-web.medium.com/\">팔로우</a></p>\n<p><a href=\"https://easy-web.medium.com/subscribe\">구독</a></p>\n<blockquote>\n<p>🚀 한국어로 된 프런트엔드 아티클을 빠르게 받아보고 싶다면 Korean FE Article(<a href=\"https://kofearticle.substack.com/\">https://kofearticle.substack.com/</a>)을 구독해주세요!</p>\n</blockquote>","frontmatter":{"title":"(번역) 🔥 자바스크립트 메모리 관리: 일반적인 메모리 누수를 방지하고 성능을 개선하는 방법","date":"March 30, 2023","thumbnail":null}}},"pageContext":{"slug":"/translation/javascript_memory_management/","previous":{"fields":{"slug":"/translation/10_web_development_trends_in_2023/"},"frontmatter":{"title":"(번역) 2023년 웹 개발 트렌드 10가지","category":"Translation","draft":false}},"next":null}},"staticQueryHashes":["3128451518","521680639"]}