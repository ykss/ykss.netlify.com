{"componentChunkName":"component---src-templates-blog-post-js","path":"/typescript/effective_ts(6)/","result":{"data":{"site":{"siteMetadata":{"title":"Ykss","author":"[Ykss]","siteUrl":"https://ykss.netlify.app","comment":{"disqusShortName":"","utterances":"ykss/ykss.netlify.com"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"417d44b4-9fce-5f2f-a872-34e77fc5a713","excerpt":"아이템 41 : any의 진화를 이해하기 any 타입은 확장되며 진화할 수 있다. 분기에 따라서 변경될 수도 있다. 하지만 any 타입은 noImplicitaAny가 설정된 상태에서 타입이 암시적 any인 경우에만 일어난다. 명시적으로 any를 선언하면 타입이 그대로 유지된다. any 탕비의 진화는 암시적 any…","html":"<h2 id=\"아이템-41--any의-진화를-이해하기\" style=\"position:relative;\"><a href=\"#%EC%95%84%EC%9D%B4%ED%85%9C-41--any%EC%9D%98-%EC%A7%84%ED%99%94%EB%A5%BC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0\" aria-label=\"아이템 41  any의 진화를 이해하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>아이템 41 : any의 진화를 이해하기</h2>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">// Type is any[]</span>\nresult<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">)</span>\nresult <span class=\"token comment\">// Type is string[]</span>\nresult<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\nresult <span class=\"token comment\">// Type is (string | number)[]</span></code></pre></div>\n<p>any 타입은 확장되며 진화할 수 있다. 분기에 따라서 변경될 수도 있다. 하지만 any 타입은 noImplicitaAny가 설정된 상태에서 타입이 암시적 any인 경우에만 일어난다. 명시적으로 any를 선언하면 타입이 그대로 유지된다. any 탕비의 진화는 암시적 any 타입에 어떤 값을 할당할때만 발생한다.</p>\n<h3 id=\"요약\" style=\"position:relative;\"><a href=\"#%EC%9A%94%EC%95%BD\" aria-label=\"요약 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>요약</h3>\n<ul>\n<li>일반적인 타입들은 정제되기만 하는 반면, 암시적 <code class=\"language-text\">any</code>와 <code class=\"language-text\">any[]</code>타입은 진화할 수 있다. 이러한 동작을 이해할 수 있어야 한다.</li>\n<li><code class=\"language-text\">any</code>를 진화 시키는 방식보다 명시적 타입 구문을 사용하는 것이 안전한 타입을 유지하는 방법이다.</li>\n</ul>\n<h2 id=\"아이템-42--모르는-타입의-값에는-any-대신-unknown을-사용하기\" style=\"position:relative;\"><a href=\"#%EC%95%84%EC%9D%B4%ED%85%9C-42--%EB%AA%A8%EB%A5%B4%EB%8A%94-%ED%83%80%EC%9E%85%EC%9D%98-%EA%B0%92%EC%97%90%EB%8A%94-any-%EB%8C%80%EC%8B%A0-unknown%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"아이템 42  모르는 타입의 값에는 any 대신 unknown을 사용하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>아이템 42 : 모르는 타입의 값에는 any 대신 unknown을 사용하기</h2>\n<p><code class=\"language-text\">unknown</code> 타입을 이해하려면 할당 가능성의 관점에서 <code class=\"language-text\">any</code>를 생각해봐야 한다. <code class=\"language-text\">any</code>는 두 가지 특징 때문에 강력하면서도 위험하다.</p>\n<ol>\n<li>어떠한 타입이든 <code class=\"language-text\">any</code> 타입에 할당 가능하다.</li>\n<li><code class=\"language-text\">any</code> 타입은 어떠한 타입으로도 할당 가능하다. (<code class=\"language-text\">never</code>타입 예외)</li>\n</ol>\n<p>타입 체커는 집합 기반이기 때문에 <code class=\"language-text\">any</code>를 사용하면 타입 체커가 무용지물이 될 수 있다. <code class=\"language-text\">unknown</code>은 <code class=\"language-text\">any</code>대신 쓸 수 있는 타입 시스템에 부합하는 타입이다. 위 <code class=\"language-text\">any</code>의 특징 중 첫 번째 속성을 만족하지만, 두 번째 속성은 만족하지 않는다. <code class=\"language-text\">never</code> 타입의 경우는 정반대로 첫 번째는 만족하지 않지만, 두 번째 속성은 만족한다.</p>\n<p><code class=\"language-text\">unknown</code> 타입인 채로 값을 사용하면 오류가 발생한다. <code class=\"language-text\">unknown</code> 값에 함수 호출을하거나 연산을 해도 마찬가지이다. 그래서 타입 단언을 하거나, <code class=\"language-text\">instanceof</code>를 체크한 후 원하는 타입으로 변환할 수 있다. 그리고 사용자 정의 타입 가드를 통해서도 <code class=\"language-text\">unknown</code>에서 원하는 타입으로 변경 가능하다.</p>\n<blockquote>\n<p>사용자 정의 타입 가드 (User-Defined Type Guards)</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">isBook</span><span class=\"token punctuation\">(</span>val<span class=\"token operator\">:</span> <span class=\"token builtin\">unknown</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> val <span class=\"token keyword\">is</span> Book <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">typeof</span> val <span class=\"token operator\">===</span> <span class=\"token string\">'object'</span> <span class=\"token operator\">&amp;&amp;</span>\n    val <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span>\n    <span class=\"token string\">'name'</span> <span class=\"token keyword\">in</span> val <span class=\"token operator\">&amp;&amp;</span>\n    <span class=\"token string\">'author'</span> <span class=\"token keyword\">in</span> val\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">processValue</span><span class=\"token punctuation\">(</span>val<span class=\"token operator\">:</span> <span class=\"token builtin\">unknown</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isBook</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    val <span class=\"token comment\">// Type is Book</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>일부 스코프에서 타입을 보장하는 런타임 검사를 수행하는 표현식으로 위와 같이 <code class=\"language-text\">argName is Type</code> 의 명제 형태로 사용되는 것이다. <code class=\"language-text\">타입가드의 return 값이 true이면 명제가 옳다는 것으로 인식한다</code>. 위에서는 아래 retrun 값이 <code class=\"language-text\">true</code> 면 <code class=\"language-text\">val</code>은 <code class=\"language-text\">Book</code>이다라고 볼 수 있다.</p>\n</blockquote>\n<h3 id=\"요약-1\" style=\"position:relative;\"><a href=\"#%EC%9A%94%EC%95%BD-1\" aria-label=\"요약 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>요약</h3>\n<ul>\n<li><code class=\"language-text\">unknown</code> 타입은 <code class=\"language-text\">any</code> 대신 사용할 수 있는 안전한 타입이다. 어떠한 값이 있지만 그 타입을 알지 못하는 경우엔 <code class=\"language-text\">unknown</code>을 사용하면 된다.</li>\n<li>사용자가 타입 단언문이나 타입 체크를 사용하도록 강제하려면 <code class=\"language-text\">unknown</code>을 사용하면 된다.</li>\n<li><code class=\"language-text\">{}</code>,<code class=\"language-text\">object</code>,<code class=\"language-text\">unknown</code>의 차이점을 이해해야 한다.</li>\n</ul>\n<h2 id=\"아이템-43--몽키-패치보다는-안전한-타입을-사용하기\" style=\"position:relative;\"><a href=\"#%EC%95%84%EC%9D%B4%ED%85%9C-43--%EB%AA%BD%ED%82%A4-%ED%8C%A8%EC%B9%98%EB%B3%B4%EB%8B%A4%EB%8A%94-%EC%95%88%EC%A0%84%ED%95%9C-%ED%83%80%EC%9E%85%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"아이템 43  몽키 패치보다는 안전한 타입을 사용하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>아이템 43 : 몽키 패치보다는 안전한 타입을 사용하기</h2>\n<p>자바스크립트의 가장 유명한 특징 중 하나는 객체와 클래스에 임의의 속성을 추가할 수 있을 만큼 유연하다는 것이다. 하지만 객체에 임의의 속성을 추가하는 것은 일반적으로 좋은 설계가 아니다. 타입스크립트까지 더하면 타입체커가 임의로 추가한 속성에 대해서 알지 못한다는 문제가 발생한다. 이 문제의 간단한 해결 방법은 <code class=\"language-text\">any</code> 단언문을 사용하는 것이지만 타입 안정성을 상실하고 언어 서비스를 사용할 수 없게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\">document<span class=\"token punctuation\">.</span>monkey <span class=\"token operator\">=</span> <span class=\"token string\">'Tamarin'</span>\n<span class=\"token comment\">// ~~~~~~ Property 'monkey' does not exist on type 'Document'</span>\n<span class=\"token punctuation\">;</span><span class=\"token punctuation\">(</span>document <span class=\"token keyword\">as</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>monkey <span class=\"token operator\">=</span> <span class=\"token string\">'Tamarin'</span> <span class=\"token comment\">// OK</span>\n<span class=\"token punctuation\">;</span><span class=\"token punctuation\">(</span>document <span class=\"token keyword\">as</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>monky <span class=\"token operator\">=</span> <span class=\"token string\">'Tamarin'</span> <span class=\"token comment\">// Also OK, misspelled</span>\n<span class=\"token punctuation\">;</span><span class=\"token punctuation\">(</span>document <span class=\"token keyword\">as</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>monkey <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">Tamarin</span><span class=\"token regex-delimiter\">/</span></span> <span class=\"token comment\">// Also OK, wrong type</span></code></pre></div>\n<p>그렇기 때문에 최선의 해결책은 document 또는 DOM으로부터 데이터를 분리하는 것이다. 객체와 데이터가 붙어 있어야만 하는 라이브러리를 사용중이거나 마이그레이션 과정 중이라면 두 가지 차선책이 있다.</p>\n<ol>\n<li><code class=\"language-text\">interface</code>의 보강(augmentation)을 사용하는 방법</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Document</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/** Genus or species of monkey patch */</span>\n  monkey<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">}</span>\n\ndocument<span class=\"token punctuation\">.</span>monkey <span class=\"token operator\">=</span> <span class=\"token string\">'Tamarin'</span> <span class=\"token comment\">// OK</span></code></pre></div>\n<p>보강을 사용한 방법이 <code class=\"language-text\">any</code>보다 나은 점은 아래와 같다.</p>\n<ul>\n<li>타입이 더 안전하다. 타입 체커는 오타나 잘못된 타입의 할당을 오류로 표시한다.</li>\n<li>속성에 주석을 붙일 수 있다(TSDoc)</li>\n<li>속성에 자동완성을 사용할 수 있다.</li>\n<li>몽키 패치가 어떤 부분에 적용되었는지 기록이 남는다.</li>\n</ul>\n<p>모듈 관점에서 제대로 동작하게 하려면 <code class=\"language-text\">global</code>선언을 추가해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">export</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">declare</span> global <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Document</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">/** Genus or species of monkey patch */</span>\n    monkey<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\ndocument<span class=\"token punctuation\">.</span>monkey <span class=\"token operator\">=</span> <span class=\"token string\">'Tamarin'</span> <span class=\"token comment\">// OK</span></code></pre></div>\n<p>보강은 전역적으로 적용되기 때문에 코드의 다른 부분이나 라이브러리로부터 분리 할 수 없다. 그리고 실행되는 동안 속성을 할당하면 실행 시점에서 보강을 적용할 방법이 없다.</p>\n<ol start=\"2\">\n<li>더 구체적인 타입 단언문을 사용하는 방법</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">MonkeyDocument</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Document</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/** Genus or species of monkey patch */</span>\n  monkey<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">;</span><span class=\"token punctuation\">(</span>document <span class=\"token keyword\">as</span> MonkeyDocument<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>monkey <span class=\"token operator\">=</span> <span class=\"token string\">'Macaque'</span></code></pre></div>\n<p><code class=\"language-text\">MonkeyDocument</code>는 <code class=\"language-text\">Document</code>를 확장하기 때문에 타입 단언문은 정상이고 할당문의 타입은 안전하다. 또한 <code class=\"language-text\">Document</code> 타입을 직접 건드리지 않고도 확장하여 새로운 타입을 도입해서 모듈 영역 문제도 해결이 가능하다.</p>\n<h3 id=\"요약-2\" style=\"position:relative;\"><a href=\"#%EC%9A%94%EC%95%BD-2\" aria-label=\"요약 2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>요약</h3>\n<ul>\n<li>전역 변수나 DOM에 데이터를 저장하지 말고, 데이터를 분리하여 사용해야 한다.</li>\n<li>내장 타입에 데이터를 저장해야하는 경우, 안전한 타입 접근법 중 하나(보강이나 사용자 정의 인터페이스로 단언)을 사용해야 한다.</li>\n<li>보강의 모듈 영역 문제를 이해해야 한다.</li>\n</ul>\n<h2 id=\"아이템-44--타입-커버리지를-추적하여-타입-안정성-유지하기\" style=\"position:relative;\"><a href=\"#%EC%95%84%EC%9D%B4%ED%85%9C-44--%ED%83%80%EC%9E%85-%EC%BB%A4%EB%B2%84%EB%A6%AC%EC%A7%80%EB%A5%BC-%EC%B6%94%EC%A0%81%ED%95%98%EC%97%AC-%ED%83%80%EC%9E%85-%EC%95%88%EC%A0%95%EC%84%B1-%EC%9C%A0%EC%A7%80%ED%95%98%EA%B8%B0\" aria-label=\"아이템 44  타입 커버리지를 추적하여 타입 안정성 유지하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>아이템 44 : 타입 커버리지를 추적하여 타입 안정성 유지하기</h2>\n<p><code class=\"language-text\">noImplicitAny</code>를 설정해도 여전히 모든 <code class=\"language-text\">any</code> 타입과 관련된 문제로 안전하다고 할 순 없다. 여전히 프로그램 내에 두 가지 경우로 존재할 수 있다.</p>\n<ul>\n<li>\n<p>명시적 <code class=\"language-text\">any</code> 타입</p>\n<p><code class=\"language-text\">any</code>타입의 범위를 좁히고 구체적으로 만들어도 여전히 <code class=\"language-text\">any</code>타입이다.</p>\n</li>\n<li>\n<p>서드파티 타입 선언</p>\n<p>@types 선언 파일로부터 <code class=\"language-text\">any</code> 타입이 전파되기 때문에 특별히 더 조심해야 한다. 절대 <code class=\"language-text\">any</code>를 사용하지 않았다 하더라도 여전히 <code class=\"language-text\">any</code> 타입은 코드 전반에 영향을 미친다.</p>\n</li>\n</ul>\n<p>npm의 <code class=\"language-text\">type-coverage</code> 패키지를 통해 <code class=\"language-text\">any</code>를 추적할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ npx type-coverage</code></pre></div>\n<h3 id=\"요약-3\" style=\"position:relative;\"><a href=\"#%EC%9A%94%EC%95%BD-3\" aria-label=\"요약 3 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>요약</h3>\n<ul>\n<li><code class=\"language-text\">noImplicitAny</code>가 설정되어 있어도, 명시적 <code class=\"language-text\">any</code> 또는 서드파티 타입 선언(@types)을 통해 <code class=\"language-text\">any</code> 타입은 코드내에 여전히 존재할 수 있다.</li>\n<li>작성한 프로그램의 타입이 얼마나 잘 선언되는지 추적해야 한다. 추적을 통해 <code class=\"language-text\">any</code>의 사용을 줄여 나갈 수 있고 타입 안정성을 꾸준히 높일 수 있다.</li>\n</ul>\n<h1 id=\"6장-타입-선언과-types\" style=\"position:relative;\"><a href=\"#6%EC%9E%A5-%ED%83%80%EC%9E%85-%EC%84%A0%EC%96%B8%EA%B3%BC-types\" aria-label=\"6장 타입 선언과 types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6장. 타입 선언과 @types</h1>\n<h2 id=\"아이템-45--devdependencies에-typescript와-types-추가하기\" style=\"position:relative;\"><a href=\"#%EC%95%84%EC%9D%B4%ED%85%9C-45--devdependencies%EC%97%90-typescript%EC%99%80-types-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0\" aria-label=\"아이템 45  devdependencies에 typescript와 types 추가하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>아이템 45 : devDependencies에 typescript와 @types 추가하기</h2>\n<p>npm은 세 가지 종류의 의존성을 구분해서 관리하며, 각각의 의존성은 <code class=\"language-text\">package.json</code> 파일 내에 별도 영역에 들어 있다.</p>\n<ul>\n<li>dependencies : 프로젝트를 실행하는데 필수적인 라이브러리가 포함된다. 프로젝트를 npm에 공개해서 다른 사용자가 해당 프로젝트를 설치하면, dependencies에 들어 있는 라이브러리도 함께 설치된다. 이것을 전이(transitve) 의존성이라고 한다.</li>\n<li>devDependencies : 개발하고 테스트하는데 사용되지만, 런타임에는 필요없는 라이브러리가 포함된다. 프로젝트를 npm에 공개하여 다른 사용자가 해당 프로젝트를 설치하면, devDependencies에 포함된 라이브러리들은 제외된다는 것이 dependencies와 다른 점이다.</li>\n<li>peerDependencies : 런타임에 필요하나 의존성을 직접 관리하지 않는 라이브러리들이 포함된다. 플러그인이 그 예시이다.</li>\n</ul>\n<p>타입스크립트 자체 의존성의 경우, devDependencies에 넣어 관리하는 것이 좋다. 그리고 타입 의존성(@types)을 고려해야 한다. DefinitelyTyped의 타입 정의들은 npm 레지스트리의 @types 스코프에 공개된다.</p>\n<h3 id=\"요약-4\" style=\"position:relative;\"><a href=\"#%EC%9A%94%EC%95%BD-4\" aria-label=\"요약 4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>요약</h3>\n<ul>\n<li>타입스크립트를 시스템 레벨로 설치하면 안 된다. 타입스크립트를 프로젝트의 devDependencies에 포함시키고 모두 같은 버전을 사용하도록 해야된다.</li>\n<li>@types 의존성은 dependencies가 아니라 devDependencies에 포함시켜야 한다. 런타입에 @types가 필요한 경우라면 별도의 작업이 필요하다.</li>\n</ul>\n<h2 id=\"아이템-46--타입-선언과-관련된-세-가지-버전-이해하기\" style=\"position:relative;\"><a href=\"#%EC%95%84%EC%9D%B4%ED%85%9C-46--%ED%83%80%EC%9E%85-%EC%84%A0%EC%96%B8%EA%B3%BC-%EA%B4%80%EB%A0%A8%EB%90%9C-%EC%84%B8-%EA%B0%80%EC%A7%80-%EB%B2%84%EC%A0%84-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0\" aria-label=\"아이템 46  타입 선언과 관련된 세 가지 버전 이해하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>아이템 46 : 타입 선언과 관련된 세 가지 버전 이해하기</h2>\n<p>타입스크립트를 사용하면 세 가지 사항을 추가로 고려해야 한다.</p>\n<ul>\n<li>라이브러리 버전</li>\n<li>타입 선언(@types) 버전</li>\n<li>타입스크립트 버전</li>\n</ul>\n<p>보통 특정 라이브러리는 dependencies에 설치하고 타입 정보는 devDependencies에 설치한다.</p>\n<p>하지만 실제 라이브러리와 타입 정보의 버전이 별도로 관리되는 방식은 문제점이 있다.</p>\n<ol>\n<li>라이브러리를 업데이트했지만 실수로 타입 선언은 업데이트하지 않는 경우 - 라이브러리 업데이트와 관련된 새로운 기능 사용 시 타입 오류 발생</li>\n<li>라이브러리보다 타입 선언의 버전이 최신인 경우 - 타입 체커는 최신 API를 기준으로 검사하나 실제로 쓰이는 것은 과거 버전이기 때문에 문제가 발생</li>\n<li>프로젝트에서 사용하는 타입스크립트 버전보다 라이브러리에서 필요로하는 타입스크립트 버전이 최신인 경우</li>\n<li>@types 의존성이 중복되는 경우</li>\n</ol>\n<p>자체적인 타입 선언은 보통 <code class=\"language-text\">package.json</code>의 types 필드에서 <code class=\"language-text\">.d.ts</code> 파일을 가르키도록 되어 있다. 번들링하여 타입 선언을 하는 경우 부수적인 네 가지 문제점이 있다.</p>\n<ol>\n<li>번들된 타입 선언에 보강 기법으로 해결할 수 없는 오류가 있는 경우</li>\n<li>프로젝트 내의 타입 선언이 다른 라이브러리 타입 선언에 의존하는 경우</li>\n<li>프로젝트의 과거 버전에 있는 타입 선언에 문제가 있는 경우</li>\n<li>타입 선언의 패치 업데이트를 자주 하기 어려운 문제</li>\n</ol>\n<h3 id=\"요약-5\" style=\"position:relative;\"><a href=\"#%EC%9A%94%EC%95%BD-5\" aria-label=\"요약 5 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>요약</h3>\n<ul>\n<li>@types 의존성과 관련된 세 가지 버전이 있다. 라이브러리 버전, @types 버전, 타입스크립트 버전이다.</li>\n<li>라이브러리 업데이트 시, 해당 @types 역시 업데이트 해야 한다.</li>\n<li>타입 선언을 라이브러리에 포함하는 것과 DefinitelyTyped에 공개하는 것 사이에 장단점을 이해해야 한다. 타입스크립트로 작성되었으면 자체 포함하고, 자바스크립트로 작성된 라이브러리면 타입 선언을 DefinitelyTyped에 공개하는 것이 좋다. (타입스크립트 패키지는 자동으로 @types를 만들어준다.)</li>\n</ul>\n<h2 id=\"아이템-47--공개-api에-등장하는-모든-타입을-익스포트하기\" style=\"position:relative;\"><a href=\"#%EC%95%84%EC%9D%B4%ED%85%9C-47--%EA%B3%B5%EA%B0%9C-api%EC%97%90-%EB%93%B1%EC%9E%A5%ED%95%98%EB%8A%94-%EB%AA%A8%EB%93%A0-%ED%83%80%EC%9E%85%EC%9D%84-%EC%9D%B5%EC%8A%A4%ED%8F%AC%ED%8A%B8%ED%95%98%EA%B8%B0\" aria-label=\"아이템 47  공개 api에 등장하는 모든 타입을 익스포트하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>아이템 47 : 공개 API에 등장하는 모든 타입을 익스포트하기</h2>\n<h3 id=\"요약-6\" style=\"position:relative;\"><a href=\"#%EC%9A%94%EC%95%BD-6\" aria-label=\"요약 6 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>요약</h3>\n<ul>\n<li>공개 메서드에 등장한 어떤 형태의 타입이든 익스포트해야 한다. 어차피 라이브러리 사용자가 추출할 수 있기 때문에, 익스포트하기 쉽게 만드는 것이 좋다.</li>\n</ul>\n<h2 id=\"아이템-48--api-주석에-tsdoc-사용하기\" style=\"position:relative;\"><a href=\"#%EC%95%84%EC%9D%B4%ED%85%9C-48--api-%EC%A3%BC%EC%84%9D%EC%97%90-tsdoc-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"아이템 48  api 주석에 tsdoc 사용하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>아이템 48 : API 주석에 TSDoc 사용하기</h2>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token comment\">/** Generate a greeting. Result is formatted for display. */</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">greetJSDoc</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> title<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">Hello </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>title<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위처럼 JSDoc 스타일로 주석을 만들면 IDE에서 주석을 툴팁으로 표시해준다. 하지만 인라인 주석은 편집기가 표시해주지 않는다. JSDoc에는 <code class=\"language-text\">@param</code>과 <code class=\"language-text\">@returns</code> 같은 일반적 규칙을 사용할 수 있다. 타입스크립트 관점에서는 TSDoc이라고 부른다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token comment\">/**\n * Generate a greeting.\n * @param name Name of the person to greet\n * @param salutation The person's title\n * @returns A greeting formatted for human consumption.\n */</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">greetFullTSDoc</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> title<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">Hello </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>title<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위처럼 추가하면 함수 호출부분에서 각 매개변수와 관련된 설명을 보여준다. 타입 정의에도 또한 사용 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Vector3D</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token comment\">/** A measurement performed at a time and place. */</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Measurement</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/** Where was the measurement made? */</span>\n  position<span class=\"token operator\">:</span> Vector3D\n  <span class=\"token comment\">/** When was the measurement made? In seconds since epoch. */</span>\n  time<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span>\n  <span class=\"token comment\">/** Observed momentum */</span>\n  momentum<span class=\"token operator\">:</span> Vector3D\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>TSDoc 주석은 마크다운 형식으로 꾸며진다.</p>\n<h3 id=\"요약-7\" style=\"position:relative;\"><a href=\"#%EC%9A%94%EC%95%BD-7\" aria-label=\"요약 7 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>요약</h3>\n<ul>\n<li>익스포트된 함수, 클래스, 타입에 주석을 달 때는 JSDoc/TSDoc 형태를 사용하자. JSDoc/TSDoc 형태의 주석을 달면 IDE가 주석 정보를 표시해준다.</li>\n<li>@param, @returns 구문과 문서 서식을 위해 마크다운을 사용할 수 있다.</li>\n<li>주석에 타입 정보를 포함하면 안 된다.</li>\n</ul>\n<hr>\n<blockquote>\n<p>출처</p>\n</blockquote>\n<ul>\n<li><a href=\"http://book.interpark.com/product/BookDisplay.do?_method=detail&#x26;sc.prdNo=351145258&#x26;gclid=Cj0KCQiAnaeNBhCUARIsABEee8UniFRGTZglixPz3qpoEFiUCp51pwbO6zAoABlO1-GYydPPlgc2RU4aAgceEALw_wcB\">이펙티브 타입스크립트</a></li>\n</ul>","frontmatter":{"title":"[Typescript] 이펙티브 타입스크립트 정리(아이템41 ~ 48)","date":"December 28, 2021","thumbnail":null}}},"pageContext":{"slug":"/typescript/effective_ts(6)/","previous":{"fields":{"slug":"/typescript/effective_ts(5)/"},"frontmatter":{"title":"[Typescript] 이펙티브 타입스크립트 정리(아이템33 ~ 40)","category":"Typescript","draft":false}},"next":{"fields":{"slug":"/typescript/effective_ts(7)/"},"frontmatter":{"title":"[Typescript] 이펙티브 타입스크립트 정리(아이템49 ~ 56)","category":"Typescript","draft":false}}}},"staticQueryHashes":["3128451518","521680639"]}