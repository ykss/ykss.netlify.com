---
title: '[BOJ] 수 찾기'
date: 2021-02-06 01:00:00
category: 'Algorithm'
draft: false
---

### 문제

N개의 정수 A[1], A[2], …, A[N]이 주어져 있을 때, 이 안에 X라는 정수가 존재하는지 알아내는 프로그램을 작성하시오.

### 입력

첫째 줄에 자연수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 줄에는 N개의 정수 A[1], A[2], …, A[N]이 주어진다. 다음 줄에는 M(1 ≤ M ≤ 100,000)이 주어진다. 다음 줄에는 M개의 수들이 주어지는데, 이 수들이 A안에 존재하는지 알아내면 된다. 모든 정수의 범위는 -231 보다 크거나 같고 231보다 작다.

### 출력

M개의 줄에 답을 출력한다. 존재하면 1을, 존재하지 않으면 0을 출력한다.

### 예제 입출력

| 입력                                      | 출력                              |
| ----------------------------------------- | --------------------------------- |
| 5 </br> 4 1 5 2 3 </br> 5 </br> 1 3 7 9 5 | 1 </br> 1 </br> 0 </br> 0 </br> 1 |

---

### 내 코드

```python
N = int(input())
aList = list(map(int,input().split(' ')))
M = int(input())
xList = list(map(int,input().split(' ')))
answer = []
for x in xList :
    if x in aList :
        answer.append(1)
    else :
        answer.append(0)
for i in range(len(answer)) :
    print(answer[i])
```

문제를 정말 단순하게 풀었는데, 단순한 로직으로 풀 수는 있는 문제였다. 하지만 `python3`로 제출했을 때는 시간 초과가 떠서, 속도가 좀 더 빠른 `pypy`로 제출했더니 정답으로 나와서 그냥 넘어가긴 했는데, 시간 초과가 났던 코드이다 보니 효율성에 대해서 더 생각해봐야 할 부분이 있는 것 같다.

### 다른 사람의 코드

```python
n = int(input())
array = set(map(int,input().split()))
m = int(input())
x = list(map(int,input().split()))
for i in x :
    if i not in array :
        print('0')
    else :
        print('1')
```

가장 큰 차이는 `set` 자료구조를 사용한 것이다. `set()`을 사용하면 기존에 배열로 저장한 것과 달리 `{}`과 같은 집합으로 저장하게 되는데, 특징으로는 중복 값을 저장하지 않는다. 그렇기 때문에 위와 같이 포함관계를 확인할 때는 중복을 제거해주기 때문에 더 효율적인 방법이라고 할 수 있다. 매우 사소한 차이 같지만 효율성을 높일 수 있는 방법이고, 또 `answer` 배열을 만들 필요 없이 바로 `print()` 하면 되는 것인데, 괜히 `answer` 배열을 만들어서 넣어주고 그걸 다시 출력하도록 한 것은 내 코드에 비효율적인 부분이 상당히 많다는 것을 느끼게 된 부분이었다. 코드를 짜고 답이 구해졌다고 하더라도 한번 더 코드를 보면서 더 간결하고 효율적이게 고칠 수 있는지 고민해보는 연습이 필요할 것 같다.
