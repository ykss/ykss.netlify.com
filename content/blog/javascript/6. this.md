# 6. this

### 1. this 바인딩

* 전역공간에서 

  * window (브라우저 콘솔에서)
  * global (node.js에서)

* 함수 내부에서

  * default 값은 전역 객체인데, 바뀔 수 있다.
  * window (브라우저 콘솔에서)
  * global (node.js에서)

* 메소드에서 호출시

  * 메소드 호출 주체 (메소드명 앞)
  * 함수는 __전역객체의__ 메소드이다.

* Callback에서

  * 기본적으로는 함수 내부에서와 동일
  * 제어권을 가진 함수가 callback의 this를 명시한 경우 그에 따른다.
  * 개발자가 this를 바인딩한 채로 callback을 넘기면 그에 따른다.

* 생성자 함수에서

  * 인스턴스

    ```javascript
    function Person(n, a) {
    	this.name = n;
    	this.age = a;
    }
    var yu = new Person('yu',28);
    console.log(yu);
    ```

    

### 2. 내부 함수에서의 우회법

```javascript
var a = 10;
var obj = {
	a: 20,
	b: function() {
		var self = this;
		console.log(this.a);
		
		function c() {
			console.log(self.a)
		}
		c();
	}
}
obj.b();
```

* self, that, _this 등의 명칭으로 주로 사용한다.



### 3. 명시적인 this 바인딩

```javascript
func.call(thisArg[, arg1[, arg2[, ...]]]) // thisArg는 this를 바인딩할 대상

func.apply(thisArg, [argsArray])

func.bind(thisArg[, arg1[, arg2[, ...]]])

// 결과는 모두 동일
// Object {c:"eee"} 1 2 3

function a(x,y,z) {
    console.log(this, x, y, z);
}
var b = {
    c: 'eee'
};

a.call(b,1,2,3);

a.apply(b,[1,2,3]);

var c = a.bind(b);
c(1,2,3);

var d = a.bind(b,1,2);
d(3);
```

* call과 apply는 즉시 호출
* call과 apply의 차이는 매개변수를 쭉 받는지 아니면 배열로 받느냐의 차이이다.
* bind는 새로운 함수 생성 (currying) -> 호출을 하진 않는다.