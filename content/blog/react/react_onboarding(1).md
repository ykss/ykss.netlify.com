---
title: '[실전리액트프로그래밍] 1. 리액트 프로젝트 시작하기'
date: 2022-05-29 01:00:00
category: 'React'
draft: true
---

- 리액트의 특징
  자바스크립트는 ECMA script로 이루어져있다.

ECMA script, BOM(browser object model), DOM 세 개가 합쳐진 것이 자바스크립트

자바스크립트는 상표 명

서버쪽 자바스크립트(Node.js)에서는 ECMAscript라고 보면된다.

BOM
가상 DOM을 이용하여 UI를 빠르게 업데이트

Virtual DOM은 리액트 뿐만 아니라 뷰에서도 사용한다.

리액트에서는 가상 돔을 사본으로 가지고 있다가, 변경점만 찾아서 업데이트 한다.

함수형 프로그래밍을 적극적으로 활용한다. 이 때 다음 두 가지 조건을 지키는 것이 좋다. (그러나 사실상 함수형 프로그래밍은 아니며, 함수 컴포넌트를 사용한다.)

render 함수는 순수 함수로 작성한다.

state는 불변 변수로 관리한다.

순수 함수와 불변 변수를 적극 사용하면 복잡도가 낮아지고, 찾기 힘든 버그가 발생할 확률이 줄어든다.

렌더링 성능을 크게 향상 시킬 수 있다.

선언적 프로그래밍 => 모든 함수가 값으로 치환 되는 것

함수형 프로그래밍의 컨셉과 순수 함수 예시,[JS] 함수형 프로그래밍,변하지 않는 상태를 유지하는 방법, 불변성(Immutable),수학에서 기원한 프로그래밍 패러다임, 순수 함수

props는 컴포넌트 사이에 전달하는 목적, state는 단일 컴포넌트 내에서 사용하는 목적이다.

리액트는 뷰에 비해 명시적으로 나눠져 있지 않다. 백엔드에서도 뷰를 선호하는 이유가 이것 때문이다.

순수 함수(pure function) : 매개변수 외에 다른 변수에 접근하지 않는 함수

- 유용한 순수 함수는 한 개 이상의 매개변수를 가지고, 반드시 반환 값이 있다.

- 같은 input을 넣었을 때, 항상 같은 output이 반환된다.

- 함수 외부의 상태를 변경하거나, 외부의 상태에 영향을 받지 않는다.

- Side Effect를 없앨 수 있다. (부수 효과)

불변성(immutable) : 상태를 변경하지 않는 것

- 단순히 함수의 인자를 변경하지 않고, 변수를 재할당하지 않는 것만이 아니라 메모리에 이미 담겨 있는 값을 변경하지 않는 것이다.

- 참조에 의한 호출 방식을 사용하는 객체의 경우, 불변성이 깨져버릴 수 있다.

- 불변성 유지를 통해 무분별한 상태 변경을 막을 수 있고, 상태의 변경을 추적하기가 쉽다.

- 리액트나 리덕스에서도 기존 state를 직접 변경하지 않고, 새로운 객체를 생성해서 반환한다.

* 바벨(babel)의 특징
  최신 JS 문법을 지원하지 않는 환경에서도 최신 문법 사용을 가능하게 해준다.

리액트에서는 jsx 문법을 사용하기 위해 바벨을 사용한다. (바벨이 jsx문법을 createElement 함수로 변환해준다.)

React.createElement(component, props, ...children)

https://ko.reactjs.org/docs/react-without-jsx.html

코드에서 주석을 제거하거나 코드를 압축하는 용도로 사용할 수 있다.

npm과 npx의 차이

- npm (node package manager) : 패키지 매니저

  package.json에서 패키지를 관리하고, 패키지는 node_modules에 설치된다.

- npx (node package executer) : 패키지 실행 담당, npm 5.2.0 이상 부터 사용 가능

  npx로 실행할 경우, 실행이 끝난 뒤 자동으로 fallback 시켜준다. (auto-fallback).

  한 번만 실행되어야 하는 경우 적합하다. 매번 최신 버전을 설치해준다.

* 웹팩(webpack)의 특징
  JS로 만든 프로그램을 배포하기 좋은 형태로 묶어주는 도구이다.

ES6 전에는 ESM(import,export)가 지원되지 않았기 때문에, commonJS가 사용되었었다.

https://d2.naver.com/helloworld/12864

FE에서도 require 형태로 써야하는 경우가 존재한다. (commonJS를 쓰는 경우 존재)

Vue.js 에서 require문을 쓰는 경우

src에 데이터 바인딩을 하여 원하는 정적 자산의 src를 주입

https://stackoverflow.com/questions/45116796/how-to-import-and-use-image-in-a-vue-single-file-component#answers

CommonJS는 JavaScript를 브라우저에서뿐만 아니라, 서버사이드 애플리케이션이나 데스크톱 애플리케이션에서도 사용하려고 조직한 자발적 워킹 그룹

번들링 외에도 파일 압축, CSS 전처리 등 기능이 존재한다.

웹팩을 이용하면 라이브러리를 손쉽게 만들어 볼 수 있다.

- CRA (create-react-app)
  바벨, 웹팩, HMR, ES6+문법, CSS 후처리, 테스트 시스템을 포함한 리액트 기반 개발 환경을 구축해준다.

ES6의 모든 기능을 제공하는게 아니라 폴리필이 들어가있는 것이다.

js 파일, css 파일, 이미지, 폰트 파일은 src 폴더 밑에서 import로 포함시키는게 좋다. 빌드 시에 자동으로 압축되기 때문이다. 웹팩에서 해시값을 이용해서 url을 생성해주기 때문에 브라우저 캐싱 효과도 볼 수 있다.

index.html에서 메타 정보를 입력해야하는 경우라면, react-helmet과 같은 패키지를 사용해야 한다.

SEO가 중요하다면 SSR에 특화된 next.js 를 사용하는 것이 좋다.

CRA에서 테스트 파일로 인식하는 경우

**test** 폴더 밑에 있는 모든 js 파일

파일 이름이 .test.js 로 끝나는 파일

파일 이름이 .spce.js 로 끝나는 파일

설정 파일을 추출할 경우, npm run eject를 통해 내부 설정 파일을 노출시킬 수 있다. 그러나 많은 설정을 직접 해주어야 하기 때문에, 리액트 툴체인에 대해 익숙하지 않으면 번거로움이 커질 수 있다.

이 외에 설정을 변경하는 방법은 react-scripts를 포크해서 커스텀하는 방법과 react-app-rewired 패키지를 사용하는 방법이 있다.

CRA 기본 설정에서는 아무런 폴리필(polyfill)도 포함하지 않는다. ES6+에서 추가된 객체나 함수를 사용하려면 폴리필을 직접 넣어야 한다. core-js 패키지를 통해 다양한 폴리필을 선택적으로 사용 가능하다. core-js를 index.js에서 한 번만 import하면 다른 곳에서도 자유롭게 사용 가능하다. 바벨에서도 폴리필 추가가 가능하지만 불필요한 폴리필까지 포함되어 번들 크기가 커질 수 있다.

- 기능 탐지와 기능 추론

흔히 UA를 통해 브라우저를 특정하거나 폴리필이 필요한 기능을 찾을 때 사용하는 두가지의 접근방법

1. 기능 탐지 - 직접적으로 해당 기능이 포함되어 있는지 확인

2. 기능 추론 - a라는 기능이 있을 때 b라는 기능도 있을 것이라 추론

https://stackoverflow.com/questions/20104930/whats-the-difference-between-feature-detection-feature-inference-and-using-th#answers

코드 분할(code splitting)은 사용자에게 필요한 양의 코드만 분할하여 내려줄 수 있다. 그렇지 않으면 초기 로딩이 오래걸린다. 코드 스플리팅을 한다고 해서 크기 줄거나 성능이 좋아지지는 않는다.

- 환경 변수 사용하기
  CRA에서는 빌드 시점에 환경 변수를 코드로 전달 가능하다. 환경 변수는 개발, 테스트, 배포 환경 별로 다른 값을 적용할 때 유용하다. process.env.{환경변수 명}으로 접근 가능하다.

npm start : development

npm test : test

npm run build : production

- 기타 환경 변수 이용하기

REACT*APP*변수명 과 같이 이름을 정하고, 코드에서는 process.env.REACT*APP*\* 와 같이 접근한다.

- autoprefixer
  CSS에서 비교적 최신 기능을 이용할 때는 벤더 접두사를 붙여야 한다. autoprefixer 패키지를 통해 벤더 접두사를 자동으로 붙힐 수 있다. CRA에서도 autoprefixer가 내장되어 제공된다.

* CSS 방식
  일반적인 css를 사용할 경우, 재 사용하기 어렵고 클래스명 중복 등으로 인해 충돌할 가능성이 있다.

css-module 은 클래스명 충돌의 위험을 막아 줄 수 있다.

CRA에서는 {이름}.module.css 의 형태로 작성하면된다. 각 클래스명에 고유한 해시값을 넣어 주어서 충돌을 막는다. classnames 패키지와 함께 사용하면 코드를 개선 할 수 있다. cn 함수의 인수로 객체를 사용하면 조건부 클래스명 사용도 가능하다. (ex. { [style.big]: isBig, [style.small]: !isBig }

Sass 로 작성하는 방법도 있다. Sass에서는 변수와 믹스인(mixin) 등의 개념을 사용하여 스타일 코드를 재사용 할 수 있다. CRA에서는 Sass를 위한 빌드 시스템이 구축되어있고, scss확장자를 가지는 파일을 불러오면 자동으로 Sass 파일이 CSS파일로 컴파일된다.

css-in-js의 방식으로 styled-components와 같은 방식도 있다.

각 컴포넌트가 서로 간의 의존성을 최소화하면서 내부적으로는 응집도를 높혀야한다.

High Cohension, Loose Coupling (높은 응집도, 느슨한 결합도)

https://www.leafcats.com/68 .

응집도와 결합도는 모듈과 모듈간의 관계의 개념이다. 모듈은 하나의 기능을 수행하는 단위이며 모듈이 모여 덩어리가 되고 그것이 프로그램이 되는 것이다. 보통의 경우 모듈화 할 경우 유지 보수와 코드 재 사용성이 향상된다.

- 응집도(Cohension)

응집도는 한 모듈 내에 존재하는 함수와 데이터의 밀접한 정도를 나타낸다. 응집도가 높을 수록 서로 관련있는 함수와 데이터로 구성되며, 응집도가 낮은 경우엔 관련성이 적은 여러 기능이 하나의 모듈에 존재하게 된다.

- 결합도(Coupling)

결합도는 하나의 모듈이 다른 모듈에 의존하는 정도이다. 각 모듈이 서로 관련성이 적어야 모듈간 독립성이 높아진다. 독립성이 높으면 모듈간의 기능에 영향을 미치지 않고 데이터만 주고 받는 형태가 된다. 프로그램의 일부만 수정해야 할 경우에도 결합도가 낮아야 부분만 수정하면 되어, 유지보수가 수월하다.

- SPA 만들기

* 브라우저 히스토리 API
  SPA 구현 시 필요한 두 가지 기능

js에서 브라우저로 페이지 전환 요청을 보낼 수 있다. 단, 브라우저에서 서버로 요청을 보내지 않아야 한다.

브라우저의 뒤로 가기 같은 사용자 페이지 전환 요청을 자바스크립트에서 처리할 수 있다. 이때도 서버로 요청을 보내지 않아야 한다.

위와 같은 조건을 만족하는 브라우저 API는 pushState, replaceState 함수와 popState 이벤트이다.

- react-router-dom 사용
  브라우저 히스토리 API를 사용해도 되지만, 번거로운 점이 많기 때문에, react-router-dom이 주로 많이 사용된다.

---

출처 : [실전 리액트 프로그래밍](http://www.yes24.com/Product/Goods/74223605)
